#!/usr/bin/perl

# open database and if enrophy level is too low place data into /dev/random

use strict;

use warnings;

require "sys/ioctl.ph";

#require '_h2ph_pre.ph';

use File::Temp qw( tempdir );

use Time::HiRes qw( usleep );

use Fcntl qw(:DEFAULT :flock);

use MIME::Base64 qw(decode_base64);

use Date::Format;

$ENV{'PATH'}="/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin";

# lowest level allowed for random pool (2000 - 4096)
my $min_level=3500;

# database
my $var_area = "/var/lib/randomdata";
my $database = $var_area . "/database";
my $stats_file = "/var/run/random-add.pid";

# set priority
setpriority(0, 0, -1);

# rng address (run with --address command to get address)
my $RNDADDENTROPY=0x40085203;

# link address (write a c program and get the address from it)
if ($#ARGV eq 0 and $ARGV[0] eq "--address" ) {
	print "Please wait... getting address.\n";
	my $c_contents="
		#include <stdio.h>\n
		#include <linux/types.h>\n
		#include <linux/random.h>\n
	
		int main() {\n
			printf(\"%#08x\\n\", RNDADDENTROPY);\n
			return 0;\n
		}\n";
	# write and compile file
	my $tmpdir=tempdir ( "random-get-XXXXXXXXXXXXXXXXXXX", TMPDIR => 1, CLEANUP => 0 );
	my $c_file=$tmpdir."/rng_address.c";
	my $o_file=$tmpdir."/rng_address";
	open(CF,">".$c_file) || die "Could not write $c_file: $!";
	print CF $c_contents;
	close(CF);
	system("gcc -Wall -o \"$o_file\" \"$c_file\"");
	# get address (0x40085203)
	my $gen_RNDADDENTROPY=`$o_file`;
	chomp $gen_RNDADDENTROPY;
	# cleanup
	unlink($c_file);
	unlink($o_file);
	rmdir($tmpdir);
	# check and convert to number
	
	print "Rng address is $gen_RNDADDENTROPY\n";
	if ( "$gen_RNDADDENTROPY" ne "0x".sprintf("%X",$RNDADDENTROPY) ) {
		print "Variable \$RNDADDENTROPY is 0x".sprintf("%X",$RNDADDENTROPY)."\n";
		print "You will need to change it manually\n";
	} else {
		print "Current saved address is correct.\n";
	}
	exit;
}

use Sys::Syslog;
# log info
sub logit {
	my $msg = shift;
	openlog("random-add", 'cons,pid', 'user');
	syslog('notice', $msg);
	closelog();
	#system("logger -i -t random-collector -p kernel.info \"$msg\"");
}

# data structure for random pool adding
#struct rand_pool_info {
#	int	entropy_count;
#	int	buf_size;
#	__u32	buf[0];
#};

# wait for database if it isnt there already
if ( not -f $database ) {
	print "Database file does not exist. Waiting...";
}
while ( not -f $database ) {
	sleep(20);
	print ".";
}

### dont use sqlite as it drains the entropy ###

sub entrophy_level {
	my $levl;
	open(LEVEL,"/proc/sys/kernel/random/entropy_avail") or die "Could not open entrophy_level: $!\n";
	$levl = <LEVEL>;
	close(LEVEL);
	chomp($levl);
	return $levl;
}

open(RD, ">>/dev/random") or die "Unable to open random device for writing: $!";

# get total data for today from stats file
my $adds=0;
my $adds_today_date=time2str("%D", time);
if ( open(STATS, "$stats_file") ) {
	my $totals = <STATS>;
	close(STATS);
	if ( defined $totals ) {
		chomp $totals;
		my @split_totals = split( / / , $totals);
		if ( $#split_totals eq 6 and $split_totals[4] eq $adds_today_date ) {
			$adds=$split_totals[6];
		}
	}
}
else {
	open(STATS, ">$stats_file");
	print STATS "\n";
	close(STATS);
	logit("Stats file created");
}
chmod 0640, $stats_file;
system("chgrp munin $stats_file");

my (@data, $rand64, $rand, $empty, $tries, $test, $size);

my $empty_notice=0; # only every hour
my $output_stats=0;
my $add_last_save=$adds;
while (1) {
	$empty=0;
	$tries=0;
	while ( entrophy_level() < $min_level and $empty eq 0 and $tries < 100 ) {
		# open and lock file
		open(DB, "+<".$database ) or die "Could not open database: $!";
		flock(DB,LOCK_EX) or die "Could not lock database: $!";
		seek(DB,-2500,2);
		$test="";
		$rand64="";
		while ($test=<DB>) { $rand64=$test; };
		seek(DB,0,2);
		truncate(DB,tell(DB) - length($rand64));
		close(DB);
		if ( $rand64 ne "" ) {
			#print $rand64;
			chomp($rand64);
			$rand=decode_base64($rand64);
			$size=length($rand);
			#print entrophy_level() . " + " . $size . "\n";
			# int, int, unsiged 32bit char (__u32)
			my $entropy_pack=pack("i i a".$size, entrophy_level(), $size, $rand);	
			
			ioctl(RD, $RNDADDENTROPY , $entropy_pack) || die "Can't ioctl: $!";
			#close(RD);
			# test for packing of random data
			#my ($e_level, $e_size, $e) = unpack("i i a".$size, $entropy_pack);
			#if ($rand ne $e) {
			#	print "\nUnpack was not equal: ".length($rand)." != ".length($e)."\n";
			#	print $rand."\n";
			#	print $e."\n";
			#}
			#if ($size ne $e_size) {
			#	print "\nSize was not equal: ".length($size)." != ".length($e_size)."\n";
			#}
			$adds += $size;
			#print ".";
		}
		else {
			$empty = 1;
			if ( time - $empty_notice > 3600 ) {
				logit("ERROR: Entrophy database is empty");
				$empty_notice=time;
			}
			sleep 10;
		}
		#sleep 1;
		usleep(5000);
		$tries++;
	}
	#update total data
	if ( $add_last_save ne $adds and time - $output_stats > 30 ) {
		# is it a new day
		if ( $adds_today_date ne time2str("%D", time) ) {
			$adds=0;
			$adds_today_date=time2str("%D", time);
		}
		# Total added bytes for 03/30/09 is 685950403
		if ( open(STATS, ">$stats_file")) {
			flock(STATS,LOCK_EX);
			print STATS "Total added bytes for " . time2str("%D", time) . " is $adds\n";
			close(STATS);
		}
		else {
			logit("ERROR: Unable to open stats file");
		}
		$output_stats=time;
		$add_last_save=$adds;
		#print "added\n";
	}
	
#	sleep 1;
	usleep(50000);
}
