#!/usr/bin/perl -w

#get random data from various sources and place it in the darabase

use strict;

use Fcntl qw(:DEFAULT :flock);

use MIME::Base64 qw(encode_base64);

use Cwd;
use Cwd qw(abs_path);
use Sys::Syslog;
use File::Basename;

my $var_area = "/var/lib/randomdata";
my $database = $var_area . "/database";

# check that we are running as non-root
die "Cannot run as root!"
	unless ( not -w "/etc" );

# check that we are running as owner of script   [ getlogin() is LAME ]
#die "Needs to run as user who owns file (".(getpwnam(getlogin()))[2].")"
#	unless ( (stat(abs_path($0)))[2] eq (getpwnam(getlogin()))[2] );

#check folder for permissions
die "Database directory does not exists"
	unless ( -d $var_area );
die "Database directory is not writable"
	unless ( -w $var_area );
my $mode = sprintf "%04o", ((stat($var_area))[2] & 07777);
die "Database directory permissions are incorrect (".$mode.")"
	unless ( $mode eq "0700" );
#die "Database directory is not owned by user"
#	unless ( (stat($var_area))[2] eq (getpwnam(getlogin()))[2] );

# set priority
setpriority(0, 0, 5);

my $dir = getcwd;
$ENV{PATH}="$dir/apps:/bin:/usr/bin:/usr/local/bin";

# log info
sub logit {
	my $msg = shift;
	openlog('random-collector', 'cons,pid', 'user');
    syslog('notice', $msg);
    closelog();
	#system("logger -i -t random-collector -p kernel.info \"$msg\"");
}

# download or obtain data
# args: <source> <destination> <amount in kb> [username] [password]
sub get_data {
	my $src = shift;
	my $dest = shift;
	my $amount = shift;
	my $testfile=$dest.".test";
	my ($x,$buf);
	$amount *= 1024 * 1024;
	if ( $src =~ m/^http/ ) {
		#download from remote location to $dest.tmp file
		logit("Web not done yet - no sites for it");
		return 1;
#		#set $src to $dest.tmp
#		$src = $dest . ".tmp"
	}
	elsif ( -C $src) {
		# get data from device
		#$amount = $amount * 18 (old: in chunks of 57 bits, in MB);
		$amount /= 1024;
		if ( not open(SAVE, ">".$dest) ) {
			logit("Could not open destination($!): $dest");
			return 1;
		}
		chmod 0600, $dest;
		if ( not open(FILE, $src) ) {
			logit("Could not open source($!): $src");
			close(SAVE);
			unlink $dest;
			return 2
		}
		for ($x=1; $x <= $amount ; $x++) {
			read(FILE, $buf, 1024);
			print SAVE $buf;
		}
		close(SAVE);
		close(FILE);
	}
	else {
		my $fullpath="";
		my @paths = split (/:/ , $ENV{PATH});
		foreach my $path ( @paths ) {
			if ( -x $path . "/" . $src ) {
				$fullpath=$path . "/" . $src;
				last;
			}
		}
		if ( $fullpath ne "" ) {
			# must be a program
			system("touch \"$dest\"");
			chmod 0600, $dest;
			#chdir(dirname($src));
			system($fullpath . " " . $amount . " > " . $dest);
			if ( $? ne 0 ) {
				logit("Failed to run " . $fullpath . " " . $amount . " > " . $dest);
				return 5;
			}
			#chdir(dirname(abs_path($0)));
		}
		elsif ( not -e $src ) {
			# not supported
			logit("Entry \"$src\" does not exist or was not in path: ".$ENV{PATH});
			#die "Entry \"$src\" is of a type that is not supported...";
			return 7;
		}
		else {
			# not supported
			logit("Entry \"$src\" is of a type that is not supported.");
			#die "Entry \"$src\" is of a type that is not supported...";
			return 7;
		}
	}
	# test for randomness
	system("cat \"$dest\" | rngtest -p > \"$testfile\" 2>/dev/null");
	# format to base64, reading parts at a time to keep memory down
	if ( -s $testfile eq 0 ) {
		logit("Output of $dest was empty (after test)");
		unlink $dest;
		unlink $testfile;
		return 4;
	}
	if ( not open(SAVE,">" . $dest) ) {
		logit ("Could not open destination($!): $dest");
		return 1;
	}
	if ( not open(FILE, $testfile) ) {
		logit("Could not open source($!): $src");
		close(SAVE);
		unlink $dest;
		return 2
	}
	# read in 57 ata time, so base64 will be okay
	while (	read(FILE, $buf, 57) eq 57 ) {
		print SAVE encode_base64($buf);
	}
	close(SAVE);
	close(FILE);
	unlink $testfile;
	return 0;
}




sub random_sort {
	my $database_name = shift;
	my @files = @_;
	#open(DATABASE,">".$destination) or die ("could not open destination: $!");
	my $f=0;
	my @fh=();
	foreach my $file (@files) {
		if ( -f $file ) {
			if ( not open($fh[$f],$file) ) {
				logit ("Could not open $file: $!");
			}
			$f++;
		}
	}
	#foreach my $fileh2 (@fh) {
	#	if ( defined($fileh2) ) {
	#		print $fileh2 . "\n";
	#	}
	#}
	
	# open database with no memory, and lock it
	my @db_array;
	my $database_tmp=$database_name."tmp";
	if ( not open (DATATMP , ">".$database_tmp) ) {
		logit("Exiting because could not clear tmp database: $!");
		exit;
	}
	chmod 0600, $database_tmp;
	close (DATATMP);
	if ( not open (DATATMP , "+<".$database_tmp) ) {
		logit("Exiting because could not open tmp database: $!");
		exit;
	}
	#my $db = tie @db_array, "Tie::File", $database_name or die "Could not open database: $!";
	#$db->flock;
	#$db->defer;
	# vars
	my $added=1;
	my ($line, $rand_each, $t, $key);
	my $full_line="";
	my $rand_lines=int( 2 + rand 6 );
	my $added_lines=0;
	#eval {
		while ($added eq 1) {
			$added=0;
			foreach my $fileh (@fh) {
				if ( defined($fileh) ) {
					# how many lines from this file?
					$rand_each=1 + int(rand 3);
					for ($t=1; $t <= $rand_each ; $t++) {
						$line = <$fileh>;
						if ( defined($line) ) {
							chomp($line);
							$full_line .= $line;
							$added=1; # if any of the files have anything left
							$added_lines++;
							# print when we have our lines
							if ($added_lines ge $rand_lines ) {
								#print DATABASE $full_line;
								#print DATABASE "----\n";
								#$key=sha1_hex(Time::HiRes::time() . $full_line);
								#print  $key . "\n";
								#unshift @db_array, $full_line;
								#$database_h->do( "INSERT INTO data VALUES ( '$full_line' )" );
								print DATATMP $full_line . "\n";
								$rand_lines=int( 2 + rand 6 );
								$added_lines=0;
								$full_line = "";
							}
						}
					}
				}
			}
		}
	#	$database_h->commit;
	#};
	#if ($@) {
    #  warn "Transaction aborted because $@";
    #  # now rollback to undo the incomplete changes
    #  # but do it in an eval{} as it may also fail
    #  eval { $database_h->rollback };
    #  # add other application on-error-clean-up code here
	#}
	# close database
	#$db->flush;
	#untie($db);
	# close and remove files
	$f=0;
	foreach my $file (@files) {
		if ( -f $file ) {
			close($fh[$f]);
			unlink $file;
			$f++;
		}
	}
	
	#sysopen(FH, "numfile", O_RDWR|O_CREAT)
    #                                or die "can't open numfile: $!";
	#flock(FH, LOCK_EX)                     		or die "can't write-lock numfile: $!";
	## Now we have acquired the lock, it's safe for I/O
	#$num = <FH> || 0;                   		# DO NOT USE "or" THERE!!
	#seek(FH, 0, 0)                      		or die "can't rewind numfile : $!";
	#truncate(FH, 0)                     		or die "can't truncate numfile: $!";
	#print FH $num+1, "\n"               		or die "can't write numfile: $!";
	#close(FH)                           		or die "can't close numfile: $!";
	
	# open and lock file
	my $data_line;
	if ( -f $database_name ) {
		if ( not open( DATABASE , "+<".$database_name ) ) {
			logit("Exiting because could not open database for copy:$!");
			exit;
		}
		flock( DATABASE , LOCK_EX);
		chmod 0600, $database_name;
		# copy old databse to new one (we are adding new ones to top for random-get's speed)
		while ($data_line = <DATABASE>) {
			print DATATMP $data_line;
		}
		# write it back
		seek(DATATMP,0,0); #rewind tmp
		seek(DATABASE,0,0); #rewind
		truncate(DATABASE,0); #clear file
		while ($data_line = <DATATMP>) {
			print DATABASE $data_line;
		}
		close(DATABASE);
		close(DATATMP);
		unlink $database_tmp;
	}
	else {
		# first run
		rename $database_tmp, $database_name;
		chmod 0600, $database_name;
	}
}

my ($r,$format_buf);

# source
while (1) {
	
	# wait if we already have enough random data stocked up
	if ( -f $database ) {
		while ( (stat($database))[7] > 30 * 1048576 ) {
			sleep(60);
		}
	}
	
	#foreach my $data
	# /dev/hrandom0
	logit("Getting random data");
	# should total 300 mb (each is in mb)
	get_data("/dev/hrandom0",	$var_area."/file1",	5);
	get_data("qrand.sh",		$var_area."/file2",	5);
	get_data("/dev/hrandom1",	$var_area."/file3",	5);
	#get_data("/dev/erandom",	$var_area."/file4",	 20);
	#get_data("MersenneTwister",	$var_area."/file5",	 50);
	
	# randomly sort data into database
	random_sort($database, $var_area."/file1", $var_area."/file2", $var_area."/file3");
		#,$var_area."/file4", $var_area."/file5");
	
	logit("Finished getting random data");
	
	# At most get data once an hour - more means trouble
	sleep(3600);
	
	#cut up into various chunks, and randowly sort
	
}

