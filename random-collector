#!/usr/bin/perl -w

#get random data from various sources and place it in the darabase

use strict;

use Fcntl qw(:DEFAULT :flock);

use MIME::Base64 qw(encode_base64);

use Cwd;
use Cwd qw(abs_path);
use Sys::Syslog;
use File::Basename;

my $var_area = "/var/lib/randomhelper";
my $database = $var_area . "/database";

my $plugin_dir = "{PREFIX}/share/randomhelper/plugins";

# log info
sub logit {
	my $msg = shift;
	openlog('random-collector', 'cons,pid', 'user');
	syslog('notice', $msg);
	closelog();
}

# check that we are running as owner of script   [ getlogin() is LAME ]
if ( not -w abs_path($0) ) {
	logit "Needs to run as user who owns file";
	print "Needs to run as user who owns file\n";
	exit;
}
# check that we are running as non-root
if ( -w "/etc" ) {
	logit "Cannot run as root!";
	print "Cannot run as root!\n";
	exit;
}

#check folder for permissions
if ( not -d $var_area ) {
	logit "Database directory does not exists";
	print "Database directory does not exists\n";
	exit;
}
if ( not -w $var_area ) {
	logit "Database directory is not writable";
	print "Database directory is not writable\n";
	exit;
}
my $mode = sprintf "%04o", ((stat($var_area))[2] & 07777);
if ( $mode ne "0700" ) {
	logit "Database directory permissions are incorrect (".$mode.")";
	print "Database directory permissions are incorrect (".$mode.")\n";
	exit;
}

if ( not -d $plugin_dir ) {
	logit "Plugin directory does not exist or is inaccessable";
	print "Plugin directory does not exist or is inaccessable";
	exit;
}

# configure
if ( $#ARGV eq 0 and $ARGV[0] eq "--config") {
	opendir(DIR,$plugin_dir) || die "Could not open $plugin_dir: $!";
	my @plugins=grep( /!^./, readdir(DIR));
	closedir(DIR);
	for my $plugin (@plugins) {
		my $plugin_run=$plugin_dir . "/" . $plugins . "/" . "run";
		if ( -x $plugin_run ) {
			system($plugin_run." --config");
		}
	}
}

# set priority
setpriority(0, 0, 2);

# wait for machine (some generators need time to startup)
sleep 15 * 60;

my $dir = getcwd;
$ENV{PATH}="$dir/apps:/bin:/usr/bin:/usr/local/bin";

# download or obtain data
# args: <source> <destination> <amount in kb> [username] [password]
sub get_data {
	my $src = shift;
	my $dest = shift;
	my $amount = shift;
	my $testfile=$dest.".test";
	my ($x,$buf);
	$amount *= 1024 * 1024;
	if ( $src =~ m/^http/ ) {
		#download from remote location to $dest.tmp file
		logit("Web not done yet - no sites for it");
		return 1;
#		#set $src to $dest.tmp
#		$src = $dest . ".tmp"
	}
	elsif ( -C $src) {
		# get data from device
		#$amount = $amount * 18 (old: in chunks of 57 bits, in MB);
		$amount /= 1024;
		if ( not open(SAVE, ">".$dest) ) {
			logit("Could not open destination($!): $dest");
			return 1;
		}
		chmod 0600, $dest;
		if ( not open(FILE, $src) ) {
			logit("Could not open source($!): $src");
			close(SAVE);
			unlink $dest;
			return 2
		}
		for ($x=1; $x <= $amount ; $x++) {
			read(FILE, $buf, 1024);
			print SAVE $buf;
		}
		close(SAVE);
		close(FILE);
	}
	else {
		my $fullpath="";
		my @paths = split (/:/ , $ENV{PATH});
		foreach my $path ( @paths ) {
			if ( -x $path . "/" . $src ) {
				$fullpath=$path . "/" . $src;
				last;
			}
		}
		if ( $fullpath ne "" ) {
			if ( open(TOUCH, ">$dest") ) {
			  print TOUCH "";
			  close(TOUCH);
			}
			chmod 0600, $dest;
			# must be a program
			#chdir(dirname($src));
			system($fullpath . " " . $amount . " > " . $dest . "&");
			my @pid = `pgrep $src`;
			if ( @pid and $#pid >= 0) {
				chomp @pid;
				# allow for a 20 kb/s connection
				my $timeout = $amount / 20;
				while ( (kill 0, @pid) > 0 and $timeout > 0 ) {
					sleep 10;
					$timeout -= 10;
				}
				# if it is still running, them stop it
				if ( (kill 0, @pid) > 0 ) {
					logit("Had to kill $src (".(kill 15, @pid)." processes)");
				}
			}
			else {
				logit("Unable to get pid for $src. Will wait 20 mins for good measure.");
				sleep(20 * 60);
			}
			if ( (stat($dest))[7] ne $amount ) {
				logit("Failed to run/finish " . $fullpath . " " . $amount . " > " . $dest);
				logit("Ouput was ".((stat($dest))[7])." ne $amount");
				# did we get at least 10% of waht we wanted?
				if ( (stat($dest))[7] < (0.10 * $amount) ) {
					# not enough
					logit("And we did not get enough data");
					unlink($dest);
					return 5;
				}
				# otherwise just log it and continue
				logit("But will continue because we got enough (".(stat($dest))[7]." bytes)");
			}
			#chdir(dirname(abs_path($0)));
		}
		else {
			# not supported
			logit "Entry \"$src\" is of a type that is not supported";
			print "Entry \"$src\" is of a type that is not supported.\n";
			return 8;
		}
	}
	# test for randomness
	if ( open(TOUCH, ">$testfile") ) {
	  print TOUCH "";
	  close(TOUCH);
	}
	chmod 0600, $testfile;
	system("cat \"$dest\" | rngtest -p > \"$testfile\" 2>/dev/null");
	# format to base64, reading parts at a time to keep memory down
	if ( -s $testfile eq 0 ) {
		logit("Output of $dest was empty (after test)");
		unlink $dest;
		unlink $testfile;
		return 4;
	}
	if ( not open(SAVE,">" . $dest) ) {
		logit ("Could not open destination($!): $dest");
		return 1;
	}
	if ( not open(FILE, $testfile) ) {
		logit("Could not open source($!): $src");
		close(SAVE);
		unlink $dest;
		return 2
	}
	# read in 57 ata time, so base64 will be okay
	while (	read(FILE, $buf, 57) eq 57 ) {
		print SAVE encode_base64($buf);
	}
	close(SAVE);
	close(FILE);
	unlink $testfile;
	return 0;
}




sub random_sort {
	my $database_name = shift;
	my @files = @_;
	my $f=0;
	my @fh=();
	foreach my $file (@files) {
		if ( -f $file ) {
			if ( not open($fh[$f],$file) ) {
				logit ("Could not open $file: $!");
			}
			$f++;
		}
	}
	
	# open database and lock it
	my $database_tmp=$database_name."tmp";
	if ( not open (DATATMP , ">".$database_tmp) ) {
		logit("Exiting because could not clear tmp database: $!");
		exit;
	}
	chmod 0600, $database_tmp;
	close (DATATMP);
	if ( not open (DATATMP , "+<".$database_tmp) ) {
		logit("Exiting because could not open tmp database: $!");
		exit;
	}
	
	# vars
	my $added=1;
	my ($line, $rand_each, $t, $key);
	my $full_line="";
	my $rand_lines=int( 2 + rand 6 );
	my $added_lines=0;
	
		while ($added eq 1) {
			$added=0;
			foreach my $fileh (@fh) {
				if ( defined($fileh) ) {
					# how many lines from this file?
					$rand_each=1 + int(rand 3);
					for ($t=1; $t <= $rand_each ; $t++) {
						$line = <$fileh>;
						if ( defined($line) ) {
							chomp($line);
							$full_line .= $line;
							$added=1; # if any of the files have anything left
							$added_lines++;
							# print when we have our lines
							if ($added_lines ge $rand_lines ) {
								print DATATMP $full_line . "\n";
								$rand_lines=int( 2 + rand 6 );
								$added_lines=0;
								$full_line = "";
							}
						}
					}
				}
			}
		}
	# close and remove files
	$f=0;
	foreach my $file (@files) {
		if ( -f $file ) {
			close($fh[$f]);
			unlink $file;
			$f++;
		}
	}
	
	# open and lock file
	my $data_line;
	if ( -f $database_name ) {
		if ( not open( DATABASE , "+<".$database_name ) ) {
			logit("Exiting because could not open database for copy:$!");
			exit;
		}
		flock( DATABASE , LOCK_EX);
		chmod 0600, $database_name;
		# copy old databse to new one (we are adding new ones to top for random-get's speed)
		while ($data_line = <DATABASE>) {
			print DATATMP $data_line;
		}
		# write it back
		seek(DATATMP,0,0); #rewind tmp
		seek(DATABASE,0,0); #rewind
		truncate(DATABASE,0); #clear file
		while ($data_line = <DATATMP>) {
			print DATABASE $data_line;
		}
		close(DATABASE);
		close(DATATMP);
		unlink $database_tmp;
	}
	else {
		# first run
		rename $database_tmp, $database_name;
		chmod 0600, $database_name;
	}
}

my ($r,$format_buf);

# source
while (1) {
		
	# wait if we already have enough random data stocked up
	if ( -f $database ) {
		while ( (stat($database))[7] > 300 * 1048576 ) {
			sleep(60);
		}
	}
	
	# hrandom0 or frandom
	my $calc_rnd0 = "/dev/hrandom0";
	my $calc_rnd1 = "/dev/hrandom1";
	if ( not -e $calc_rnd0 ) {
		logit "hrandom is not installed - reverting to frandom";
		$calc_rnd0 = "/dev/frandom";
		$calc_rnd1 = "/dev/erandom";
	}
	
	logit("Getting random data");
	
	# should total 300 mb (each is in mb)
	
	get_data($calc_rnd0,		$var_area."/file1",	50);
	get_data("qrand.sh",		$var_area."/file2",	70);
	get_data($calc_rnd1,		$var_area."/file3",	50);
	
	get_data($calc_rnd0,		$var_area."/file4",	50);
	get_data("qrand.sh",		$var_area."/file5",	70);
	get_data($calc_rnd1,		$var_area."/file6",	50);
	
	#get_data("MersenneTwister",	$var_area."/file8",	 50);
	
	# randomly sort data into database
	random_sort($database, $var_area."/file1", $var_area."/file2", $var_area."/file3"
		,$var_area."/file4", $var_area."/file5", $var_area."/file6");
	
	logit("Finished getting random data");
	
	# At most get data once an hour - more means trouble
	sleep(3600);
	
	#cut up into various chunks, and randowly sort
	
}

