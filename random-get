#!/usr/bin/perl

# open database and if enrophy level is too low place data into /dev/random

$ENV{'PATH'}="/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin";

use strict;

use warnings;

require "sys/ioctl.ph";

require '_h2ph_pre.ph';

use File::Temp qw( tempdir );

use Time::HiRes qw( usleep );

use Fcntl qw(:DEFAULT :flock);

use MIME::Base64 qw(decode_base64);

# lowest level allowed for random pool (2000 - 4096)
my $min_level=4000;

# database
my $database = "/tmp/randomdata/database";

# rng address (run with --address command to get address)
my $RNDADDENTROPY=0x40085203;

# link address (write a c program and get the address from it)
if ($#ARGV eq 0 and $ARGV[0] eq "--address" ) {
	print "Please wait... getting address.\n";
	my $c_contents="
		#include <stdio.h>\n
		#include <linux/types.h>\n
		#include <linux/random.h>\n
	
		int main() {\n
			printf(\"%#08x\\n\", RNDADDENTROPY);\n
			return 0;\n
		}\n";
	# write and compile file
	my $tmpdir=tempdir ( "random-get-XXXXXXXXXXXXXXXXXXX", TMPDIR => 1, CLEANUP => 0 );
	my $c_file=$tmpdir."/rng_address.c";
	my $o_file=$tmpdir."/rng_address";
	open(CF,">".$c_file) || die "Could not write $c_file: $!";
	print CF $c_contents;
	close(CF);
	system("gcc -Wall -o \"$o_file\" \"$c_file\"");
	# get address (0x40085203)
	my $RNDADDENTROPY=`$o_file`;
	chomp $RNDADDENTROPY;
	# cleanup
	unlink($c_file);
	unlink($o_file);
	rmdir($tmpdir);
	# check and convert to number
	
	print "Rng address is $RNDADDENTROPY\n";
	exit;
}

# data structure for random pool adding
#struct rand_pool_info {
#	int	entropy_count;
#	int	buf_size;
#	__u32	buf[0];
#};

# wait for database if it isnt there already
if ( not -f $database ) {
	print "Database file does not exist. Waiting...";
}
while ( not -f $database ) {
	sleep(20);
	print ".";
}

### dont use sqlite as it drains the entropy ###

sub entrophy_level {
	my $levl;
	open(LEVEL,"/proc/sys/kernel/random/entropy_avail") or die "Could not open entrophy_level: $!\n";
	$levl = <LEVEL>;
	close(LEVEL);
	chomp($levl);
	return $levl;
}

my (@data, $rand64, $rand, $empty, $tries, $test, $size);
my $adds=0;
while (1) {
	$empty=0;
	#$tries=0;
	while ( entrophy_level() < $min_level and $empty eq 0 ) {
		# open and lock file
		open(DB, "+<".$database ) or die "Could not open database: $!";
		flock(DB,LOCK_EX) or die "Could not lock database: $!";
		seek(DB,-2500,2);
		$test="";
		$rand64="";
		while ($test=<DB>) { $rand64=$test; };
		seek(DB,0,2);
		truncate(DB,tell(DB) - length($rand64));
		close(DB);
		if ( $rand64 ne "" ) {
			chomp($rand64);
			$rand=decode_base64($rand64);
			$size=length($rand);
			#print entrophy_level() . " + " . $size . "\n";
			# int, int, unsiged 32bit char (__u32)
			my $entropy_pack=pack("i i a".$size, entrophy_level(), $size, $rand);	
			open(RD, ">>/dev/random") or die "Unable to open random device for writing: $!";
			ioctl(RD, $RNDADDENTROPY , $entropy_pack) || die "Can't ioctl: $!";
			close(RD);
			# test for packing of random data
			#my ($e_level, $e_size, $e) = unpack("i i a".$size, $entropy_pack);
			#if ($rand ne $e) {
			#	print "\nUnpack was not equal: ".length($rand)." != ".length($e)."\n";
			#	print $rand."\n";
			#	print $e."\n";
			#}
			#if ($size ne $e_size) {
			#	print "\nSize was not equal: ".length($size)." != ".length($e_size)."\n";
			#}
			$adds += $size;
		}
		else {
			$empty = 1;
			print "Empty\n";
			sleep 10;
		}
		#sleep 1;
		usleep(50000);
		#$tries++;
	}
	#update total data
	
	sleep 1;
	print entrophy_level()." . ".$adds."\n";
}
