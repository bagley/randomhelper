#!/usr/bin/perl -w

#get random data from various sources and place it in the darabase

use strict;

use Fcntl qw(:DEFAULT :flock);

use MIME::Base64 qw(encode_base64);

use Cwd;
use Cwd qw(abs_path);
use Sys::Syslog;
use File::Basename;

#######################################

my $dir = getcwd;
$ENV{PATH}="$dir/apps:/bin:/usr/bin:/usr/local/bin";

my $var_area = "/var/lib/randomhelper";

my $database = $var_area . "/database";

my $plugin_dir = "/usr/local/share/randomhelper/plugins";

my $conf = "/etc/randomhelper";

#######################################

my $factor;

# log info
sub logit {
	my $msg = shift;
	openlog('random-collector', 'cons,pid', 'user');
	syslog('notice', $msg);
	closelog();
	print $msg . "\n";
}

sub error {
	my $msg = shift;
	logit($msg);
	exit 1;
}

# obtain data
sub get_data {
	my $src = shift;
	my $dest = shift;
	my $amount = shift;
	my $amount_bytes = $amount * 1024 * 1024;
	my $testfile=$dest.".test";
	my ($x,$buf);
	logit "Getting $amount mb from $src";
	my $src_path=$plugin_dir . "/" . $src . "/run";
	if ( -x $src_path ) {
		# run it with --get xx arg
		chdir($plugin_dir . "/" . $src);
		system("\"$src_path\" --get $amount > \"$dest\" 2>/dev/null &");
		
		# watch it
		my $timeout = $amount * 2 * 6;
		my @pid = `pgrep -f "$src_path --get $amount"`;
		if ( @pid and $#pid >= 0) {
			chomp @pid;
			# allow for a 10 kb/s program/connection
			while ( (kill 0, $pid[0]) > 0 and $timeout > 0 ) {
				sleep 10;
				$timeout -= 1;
			}
			# if it is still running, then stop it
			if ( (kill 0, $pid[0]) > 0 ) {
				logit("Had to kill $src (pid ".(kill 15, $pid[0]).")");
			}
		}
		else {
			logit("Unable to get pid for $src. Will wait ".
				($timeout / 6)." mins for good measure.");
			while ( $timeout > 0 ) {
				sleep 10;
				$timeout -= 1;
			}
		}
		
		# verify it actually did something
		if ( (stat($dest))[7] ne $amount_bytes ) {
			logit("Failed to run/finish " . $src . " " . 
				$amount_bytes . " > " . $dest);
			logit("Ouput was ".((stat($dest))[7])." != $amount");
			# did we get at least 10% of waht we wanted?
			if ( (stat($dest))[7] < (0.10 * $amount_bytes) ) {
				# not enough
				logit("And we did not get enough data");
				unlink($dest);
				return 5;
			}
			# otherwise just log it and continue
			logit("But will continue because we got enough (".(stat($dest))[7]." bytes)");
		}
	}
	else {
		# not supported
		logit "Plugin \"$src\" was not found in the plugin dir $plugin_dir";
		return 8;
	}
	
	# we will filter through rngtest to test for randomness, if available
	if ( open(TOUCH, ">$testfile") ) {
	  print TOUCH "";
	  close(TOUCH);
	}
	chmod 0600, $testfile;
	my $rngtest="none";
	foreach my $path ( split(/:/, $ENV{PATH} ) ) {
		if ( -x $path . "/rngtest" ) {
			$rngtest=$path . "/rngtest";
		}
	}
	if ( -x $rngtest ) {
		system("\"$rngtest\" -p < \"$dest\" > \"$testfile\" 2>/dev/null");
	}
	else {
		$testfile=$dest;
	}
	
	# format to base64, reading parts at a time to keep memory down
	if ( -s $testfile eq 0 ) {
		logit("Output of $dest was empty (rngtest: $rngtest)");
		unlink $dest;
		unlink $testfile;
		return 4;
	}
	if ( not open(SAVE,">" . $dest) ) {
		logit ("Could not open destination($!): $dest");
		return 1;
	}
	if ( not open(FILE, $testfile) ) {
		logit("Could not open source($!): $src");
		close(SAVE);
		unlink $dest;
		return 2
	}
	# read in 57 ata time, so base64 will be okay
	while (	read(FILE, $buf, 57) eq 57 ) {
		print SAVE encode_base64($buf);
	}
	close(SAVE);
	close(FILE);
	unlink $testfile;
	return 0;
}


sub random_sort {
	my $database_name = shift;
	my $folder=shift;
	
	# file list
	if ( not opendir(DIR, $folder) ) {
		logit "Failed to open temp folder $folder for reading: $!";
		return 5;
	}
	my @files_short = grep( !/^\.{1,2}$/, readdir(DIR));
	closedir(DIR);
	
	# full paths
	my @files = ();
	foreach my $file (@files_short) {
		push @files, $folder."/".$file;
	}
	
	# determine total file sizes , for size of chunks when we mix files
	my $total_size=0;
	my $size;
	foreach my $file (@files) {
		$size = (stat($file))[7];
		$total_size += $size;
	}
	my %file_weight=();
	
	# open files in an array
	my $f=0;
	my @fh=();
	foreach my $file (@files) {
		if ( -f $file and open($fh[$f],$file) ) {
			# determine how large the chunks will be when we mix files
			$size = (stat($file))[7];
			$file_weight{$fh[$f]}=int($size / $total_size * 20);
			if ( $file_weight{$fh[$f]} < 3 ) {
				$file_weight{$fh[$f]}=3;
			}
			#print $size." -/- ".$total_size."\n";
			#print "Weght for $file: ".$file_weight{$fh[$f]} . "\n";
		}
		else {
			logit ("Could not open $file: $!");
		}
		$f++;
	}
	
	# open temp database
	my $database_tmp=$database_name."tmp";
	if ( not open (DATATMP , ">".$database_tmp) ) {
		logit("Exiting because could not clear tmp database: $!");
		exit;
	}
	chmod 0600, $database_tmp;
	close (DATATMP);
	if ( not open (DATATMP , "+<".$database_tmp) ) {
		logit("Exiting because could not open tmp database: $!");
		exit;
	}
	
	# vars
	my $added=1;
	my ($line, $rand_each, $t, $key);
	my $full_line="";
	my $rand_lines=int( 2 + rand 6 );
	my $added_lines=0;
	
		while ($added eq 1) {
			$added=0;
			foreach my $fileh (@fh) {
				if ( defined($fileh) ) {
					# how many lines from this file? By file size (above)
					$rand_each = 1 + int(rand $file_weight{$fileh});
					# print $rand_each . "-";
					for ($t=1; $t <= $rand_each ; $t++) {
						$line = <$fileh>;
						if ( defined($line) ) {
							chomp($line);
							$full_line .= $line;
							$added=1; # if any of the files have anything left
							$added_lines++;
							# print when we have our lines
							if ($added_lines ge $rand_lines ) {
								print DATATMP $full_line . "\n";
								$rand_lines=int( 2 + rand 6 );
								$added_lines=0;
								$full_line = "";
							}
						}
					}
				}
			}
		}
	# close and remove files
	$f=0;
	foreach my $file (@files) {
		if ( -f $file ) {
			close($fh[$f]);
			unlink $file;
			$f++;
		}
	}
	
	# open and lock file
	my $data_line;
	if ( -f $database_name ) {
		if ( not open( DATABASE , "+<".$database_name ) ) {
			logit("Exiting because could not open database for copy:$!");
			exit;
		}
		flock( DATABASE , LOCK_EX);
		chmod 0600, $database_name;
		# copy old databse to new one (we are adding new ones to top for random-get's speed)
		while ($data_line = <DATABASE>) {
			print DATATMP $data_line;
		}
		# write it back
		seek(DATATMP,0,0); #rewind tmp
		seek(DATABASE,0,0); #rewind
		truncate(DATABASE,0); #clear file
		while ($data_line = <DATATMP>) {
			print DATABASE $data_line;
		}
		close(DATABASE);
		close(DATATMP);
		unlink $database_tmp;
	}
	else {
		# first run
		rename $database_tmp, $database_name;
		chmod 0600, $database_name;
	}
}


# plugin list
sub get_plugins {
	# plugin dir listing
	if ( not opendir(DIR,$plugin_dir) ) {
		logit "Could not open $plugin_dir: $!";
		return qw(size => 0);
	}
	my @p=grep( !/^\.{1,2}$/, readdir(DIR));
	closedir(DIR);
	my %plugs=();
	foreach my $plug (@p) {
		$plugs{$plug}=1;
	} 
	
	# read config
	open ( CONF , $conf ) || error("Failed to open config");
	my @conf_file=<CONF>;
	close(CONF);
	my %conf_h;
	$conf_h{size}=300;
	foreach my $c (@conf_file) {
		if ( not $c =~ /^\s*#/ ) {
			# size
			$c =~ s/size\s*=\s*(\d+)/$conf_h{size}=$1/e;
			# plugins
			$c =~ s/(.+)\s*=\s*(\d+)/$conf_h{$1}=$2/e;
		}
	}
	
	# add found plugins not in config file, with default of 5
	foreach my $plug (keys %plugs) {
		if ( not exists $conf_h{$plug} ) {
			$conf_h{$plug}=5;
		}
	}
	# remove nonexistant plugins and check values
	foreach my $c (keys %conf_h) {
	  if ( $c ne "size" ) {
		if ( not exists $plugs{$c} ) {
			delete $conf_h{$c};
			logit "Error: Plugin entry $c is in config file, but there is no folder for it";
		}
		if ( not $conf_h{$c} gt 0 and not $conf_h{$c} le 10 ) {
			logit "Plugin $c had an incorrect value amount and was reset to 5";
			$conf_h{$c}=5;
		}
	  }
	}
	
	# determine total amounts for each plugin
	$factor=0;
	foreach my $c (keys %conf_h) {
	  if ( $c ne "size" ) {
		# get multiplication factor
		$factor += $conf_h{$c};
	  }
	}
	$factor=$conf_h{size} / $factor; # determine factor
	# print $factor . "\n";
	foreach my $c (keys %conf_h) {
	  if ( $c ne "size" ) {
		# apply multiplication factor
		$conf_h{$c} = int( $conf_h{$c} * $factor );
		# print "$c = $conf_h{$c}\n";
	  }
	}
	
	return %conf_h;
}


# check that we are running as owner of script   [ getlogin() is LAME ]
if ( not -w abs_path($0) ) {
	error "Needs to run as user who owns file";
}
# check that we are running as non-root
if ( -w "/" ) {
	print "Cannot run as root!\n";
#	print "Cannot run as root! Attempting to drop privleges\n";
#	# try to drop privleges
#	my $uid=(stat($var_area))[0];
#	if ( $uid eq 0 ) {
#		error "Random user home directory $var_area is owned by root!? Exiting...";
#	}
#	my $randuser = getpwuid($uid);
#	logit "Trying as user $randuser ($uid)"; 
#	my $passargs="";
#	if ( $#ARGV eq 0 and $ARGV[0] eq "--config") { $passargs="--config"; }
#	exec("su - \"$randuser\" -c \"".abs_path($0)." $passargs\"");
	exit;
}


# vars
my $var_area_tmp = $var_area . "/tmp";
my ($r,$format_buf);
my %plugins = ();


#check folder for permissions
if ( not -d $var_area ) {
	error "Database directory $var_area does not exists";
}
if ( not -w $var_area ) {
	error "Database directory $var_area is not writable";
}
my $mode = sprintf "%04o", ((stat($var_area))[2] & 07777);
if ( $mode ne "0700" ) {
	error "Database directory $var_area permissions are incorrect (".$mode.")";
}
if ( not -d $plugin_dir ) {
	error "Plugin directory $plugin_dir does not exist or is inaccessable";
}


# make dirs and test plugin dir
mkdir $var_area_tmp || error "Unable to create temp folder $var_area_tmp";
%plugins=get_plugins();
if ( %plugins eq 0 ) {
	error("THERE ARE NO PLUGINS INSTALLED: EXITING....");
}


# configure
if ( $#ARGV eq 0 and $ARGV[0] eq "--config") {
	if ( not opendir(DIR,$plugin_dir) ) {
		print "Could not open $plugin_dir: $!";
		exit;
	}
	my @config_plugins=grep( !/^\.{1,2}$/, readdir(DIR));
	closedir(DIR);
	for my $plugin (@config_plugins) {
		my $plugin_run=$plugin_dir . "/" . $plugin . "/" . "run";
		if ( -x $plugin_run ) {
			system($plugin_run." --config");
		}
	}
	exit;
}


# set higher priority
setpriority(0, 0, 2);


# wait x mins after machine startup (some generators need time to startup)
my $wait = 15 * 60;
if ( open( UPTIME, "/proc/uptime" ) ) {
	my $uptime = ( split (/ /, (<UPTIME>)[0]) )[1];
	close(UPTIME);
	if ( $uptime < $wait ) {
		sleep $wait - $uptime;
	}
}
else {
	# not linux
	sleep $wait;
}


# main
while (1) {
	
	# plugins
	%plugins=get_plugins();
	if ( %plugins eq 0 ) {
		logit "No plugins found";
		sleep 24 * 3600;
		next;
	}
	
	# wait if we already have enough random data stocked up
	if ( -f $database ) {
		while ( (stat($database))[7] > $plugins{size} * 1048576 ) {
			sleep(300); # 5 mins
		}
	}
	
	# process plugins 
	logit("Getting random data");
	
	# two passes, to mix things up
	
	# first pass
	foreach my $plugin (keys %plugins) {
		if ( $plugin ne 'size' ) {
			get_data($plugin, $var_area_tmp."/".$plugin."-1", 
				int($plugins{$plugin} / 2) );
		}
	}
	# second pass
	foreach my $plugin (keys %plugins) {
		if ( $plugin ne 'size' ) {
			get_data($plugin, $var_area_tmp."/".$plugin."-2", 
				int($plugins{$plugin} / 2) );
		}
	}
	
	# randomize files
	logit("Putting data into database");
	random_sort($database, $var_area_tmp);
	logit("Finished getting random data");
	
	# At most get data once an hour - more means trouble
	sleep(3600);
	
}
